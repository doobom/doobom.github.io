<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>oops: run - RegEx</title><link href="https://doobom.me/" rel="alternate"></link><link href="https://doobom.me/feeds/regex.atom.xml" rel="self"></link><id>https://doobom.me/</id><updated>2020-12-11T09:58:00+08:00</updated><subtitle>keep running...</subtitle><entry><title>正则表达式匹配数字范围</title><link href="https://doobom.me/regular-expressions-match-numeric-ranges" rel="alternate"></link><published>2020-12-11T09:58:00+08:00</published><updated>2020-12-11T09:58:00+08:00</updated><author><name>doobom</name></author><id>tag:doobom.me,2020-12-11:/regular-expressions-match-numeric-ranges</id><summary type="html">&lt;p&gt;正则表达式匹配数字范围，匹配单个数字的方式很简单，&lt;code&gt;[0-9]&lt;/code&gt;是&lt;code&gt;[0123456789]&lt;/code&gt;的简写形式，可以用来匹配任何一个数字。如果要匹配 &lt;code&gt;0&lt;/code&gt; 到 &lt;code&gt;255&lt;/code&gt; 中的所有数字，该怎么办呢？表达式&lt;code&gt;[0-255]&lt;/code&gt;并不能达到目的。&lt;/p&gt;</summary><content type="html">&lt;blockquote&gt;
&lt;p&gt;原文：
&lt;a href="https://geek-docs.com/regexp/regexp-tutorials/regular-expressions-match-numeric-ranges.html"&gt;https://geek-docs.com/regexp/regexp-tutorials/regular-expressions-match-numeric-ranges.html&lt;/a&gt;
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;正则表达式匹配数字范围，匹配单个数字的方式很简单，&lt;code&gt;[0-9]&lt;/code&gt;是&lt;code&gt;[0123456789]&lt;/code&gt;的简写形式，可以用来匹配任何一个数字。如果要匹配 0 到 255 中的所有数字，该怎么办呢？表达式&lt;code&gt;[0-255]&lt;/code&gt;并不能达到目的。&lt;/p&gt;
&lt;p&gt;下表所示为数字元字符&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;元字符&lt;/th&gt;
&lt;th align="left"&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;code&gt;\d&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;任何一个数字字符（等价于&lt;code&gt;[0-9]&lt;/code&gt;）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;code&gt;\D&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;任何一个非数字字符（等价于&lt;code&gt;[^0-9]&lt;/code&gt;）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;正则表达式是为了匹配字符而设计的，而并不是为了匹配数字，所以当你使用正则匹配指定范围内的数字的时候你需要额外小心。表达式&lt;code&gt;[0-255]&lt;/code&gt;并不能匹配 0 至 255 之间的数字。表达式&lt;code&gt;[0-255]&lt;/code&gt;是一个字符集，它的含义是匹配 0，1，2，5 中任意一个字符，这个表达式等同于&lt;code&gt;[0125]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;正则引擎真正处理的是字符，所以数字 0 对于引擎来说是一个字符，而 255 对于引擎来说是长度为 3 的字符。所以如何要匹配 0 至 255&amp;nbsp;中的所有数字，我们需要让引擎匹配长度为一到三之间的字符。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;[0-9]&lt;/code&gt; 可以匹配 0~9&amp;nbsp;之间的数字。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[1-9][0-9]&lt;/code&gt; 可以匹配 10~99&amp;nbsp;之间的数字。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[1-9][0-9][0-9]&lt;/code&gt; 可以匹配 100~999&amp;nbsp;之间的数字&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但是匹配 0~255&amp;nbsp;略微复杂一点，因为我们要排除256至999之间的整数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1[0-9][0-9]&lt;/code&gt;可以匹配 100 至 199&amp;nbsp;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;2[0-4][0-9]&lt;/code&gt;可以匹配 200 至 249&amp;nbsp;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;25[0-5]&lt;/code&gt;可以匹配 250 至 255&amp;nbsp;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;你可以发现当我们匹配 0 到 255 之间的整数时，我们需要按照字符的长度来分割这个范围。在匹配三位整数的时候，如果百位是 1 ，那么十位和个位允许出现 0 至 9 之间的 10 个字符，如果百位是 2&amp;nbsp;，那么十位和个位的字符将进一步做限制。&lt;/p&gt;
&lt;p&gt;把前面三个部分用选择符连接起来，我们就得到了 0 至 255 之间所有的整数：&lt;code&gt;[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;但是这个方法还存在一个缺陷：正则表达式通常允许部分匹配，所以这个表达式可以匹配到 12345 中的&amp;nbsp;123。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如下两种方法可以解决问题：&lt;/p&gt;
&lt;p&gt;（1）词语边界
如果你在一个文档中所搜数字，你可以使用词语边界锁定数字的范围：&lt;code&gt;\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b&lt;/code&gt;。因为选择符的优先级是最低的，所以我们要在选择外加上括号。这样引擎会先匹配第一个边界符&lt;code&gt;\b&lt;/code&gt;，然后匹配整个选择符，最后匹配最后一个&lt;code&gt;\b&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;（2）位置字符
如果你想验证用户输入内容，那么或许你想验证的是用户输入的完整内容，而不是其中的部分。你可以使用位置字符：&lt;code&gt;^([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以下一些常用的数字匹配：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;000..255: &lt;code&gt;^([01][0-9][0-9]|2[0-4][0-9]|25[0-5])$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;0 or 000..255: &lt;code&gt;^([01]?[0-9]?[0-9]|2[0-4][0-9]|25[0-5])$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;0 or 000..127: &lt;code&gt;^(0?[0-9]?[0-9]|1[01][0-9]|12[0-7])$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;0..999: &lt;code&gt;^([0-9]|[1-9][0-9]|[1-9][0-9][0-9])$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;000..999: &lt;code&gt;^[0-9]{3}$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;0 or 000..999: &lt;code&gt;^[0-9]{1,3}$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;1..999: &lt;code&gt;^([1-9]|[1-9][0-9]|[1-9][0-9][0-9])$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;001..999: &lt;code&gt;^(00[1-9]|0[1-9][0-9]|[1-9][0-9][0-9])$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;1 or 001..999: &lt;code&gt;^(0{0,2}[1-9]|0?[1-9][0-9]|[1-9][0-9][0-9])$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;0 or 00..59: &lt;code&gt;^[0-5]?[0-9]$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;0 or 000..366: &lt;code&gt;^(0?[0-9]?[0-9]|[1-2][0-9][0-9]|3[0-5][0-9]|36[0-6])$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;正整数: &lt;code&gt;^[0-9]*[1-9][0-9]*$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;负整数: &lt;code&gt;^-[0-9]*[1-9][0-9]*$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;整数: &lt;code&gt;^-?d $&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;浮点数: &lt;code&gt;^(-?d )(.d )?$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;正浮点数: &lt;code&gt;^(([0-9] .[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*.[0-9] )|([0-9]*[1-9][0-9]*))$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;复浮点数: &lt;code&gt;^(-(([0-9] .[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*.[0-9] )|([0-9]*[1-9][0-9]*)))$&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="RegEx"></category><category term="regex"></category><category term="numeric"></category></entry></feed>