var tipuesearch = {"pages":[{"title":"How to Install EPEL and REMI Repository on CentOS/RedHat 7/6","text":"原文： How to Install EPEL and REMI Repository on CentOS/RedHat 7/6 EPEL is known as Extra Packages for Enterprise Linux repository having lots of extra packages which is not added in official repositories. REMI is a third party repository provides latest version of packages which is already included in official repositories of CentOS and Red Hat. This article will help you to install EPEL and REMI repository on CentOS and Red Hat 7/6/5 systems. Install EPEL Repository EPEL release package is available under default CentOS repositories. So use the following command to install EPEL yum repository on your CentOS/ RHEL 7/6/5 systems. yum install epel-release In the case of command doesn't work for you, use one of below commands. ### For CentOS/RHEL 7 ### rpm -Uvh http://dl.fedoraproject.org/pub/epel/7/x86_64/Packages/e/epel-release-7-11.noarch.rpm ### For CentOS/RHEL 6 ### rpm -Uvh http://dl.fedoraproject.org/pub/epel/6/x86_64/epel-release-6-8.noarch.rpm Install REMI Repository Use following commands to install REMI yum repository on your CentOS/ RHEL 7/6/5 systems. Make sure you already have installed EPEL repository before installing REMI . ### For CentOS/RHEL 7 ### rpm -Uvh http://rpms.famillecollet.com/enterprise/remi-release-7.rpm ### For CentOS/RHEL 6 ### rpm -Uvh http://rpms.famillecollet.com/enterprise/remi-release-6.rpm List all Installed Repository Use following command to list all installed yum repositories in your system. yum repolist Sample Output Loaded plugins: fastestmirror Loading mirror speeds from cached hostfile * base: pubmirrors.dal.corespace.com * epel: linux.mirrors.es.net * extras: mirrors.easynews.com * remi: mirrors.mediatemple.net * updates: mirrors.easynews.com repo id repo name status base CentOS-6 - Base 6 ,518 epel Extra Packages for Enterprise Linux 6 - x86_64 11 ,153 extras CentOS-6 - Extras 37 pgdg91 PostgreSQL 9 .1 6 - x86_64 279 pgdg93 PostgreSQL 9 .3 6 - x86_64 307 puppetlabs-deps Puppet Labs Dependencies El 6 - x86_64 77 puppetlabs-products Puppet Labs Products El 6 - x86_64 475 remi Les RPM de remi pour Enterprise Linux 6 - x86_64 2 ,407 updates CentOS-6 - Updates 748 repolist: 22 ,001","tags":"Linux","url":"https://doobom.me/how-to-install-epel-and-remi-repository-on-centos","loc":"https://doobom.me/how-to-install-epel-and-remi-repository-on-centos"},{"title":"wsl centos7: Failed to get D-Bus connection Operation not permitted","text":"即然是 CentOS 那如果不能运行 service systemctl 那不是等于是残了嘛. 用的是 yuk7/CentWSL 这个 CentOS 7 装完感觉挺好的, 心里暗爽, 然后就开始折腾了. 安装 PostgreSQL 配置完了以后就准备 service postgresql start 的时候就提示了错误: Failed to get D-Bus connection Operation not permitted 查了一下，意思就是 wsl 并不支持。 不过 github 上有人解决了, 这里 大概就是这样： mv /usr/bin/systemctl /usr/bin/systemctl.old curl https://raw.githubusercontent.com/gdraheim/docker-systemctl-replacement/master/files/docker/systemctl.py > /usr/bin/systemctl chmod +x /usr/bin/systemctl 有一个介绍 wsl 的写的很详细，推友 塔Q 分享的 Dev on Windows with WSL ，值得一读. 另一个设置自动运行一文章： WSL Tips: Starting Linux Background Services on Windows Login 还有一个 repo: troytse/wsl-autostart","tags":"Windows","url":"https://doobom.me/wsl-centos7-failed-to-get-d-bus-connection-Operation-not-permitted","loc":"https://doobom.me/wsl-centos7-failed-to-get-d-bus-connection-Operation-not-permitted"},{"title":"How to enable the Windows subsystem for linux feature","text":"原文: How to enable the Windows subsystem for linux feature The Windows Subsystem for Linux ( WSL ) is an efficient way to get the benefits of different Linux operating systems on Windows 10 PC and laptops. WSL allows running of Linux apps directly on Windows 10 system without using any virtualization software like VirtualBox or VMware. The WSL is available for Windows 10 and Windows server 2019. Windows Subsystem for Linux ( WSL ) basically a compatibility layer developed by Microsoft for running Linux binaries. It doesn't contain any kind of Linux kernel code rather it uses a Linux compatible kernel interface. The disadvantage of the WSL it is not capable of running all Linux software especially those requires the Linux kernel services. We can run Linux apps in graphical mode by installing the opensource X11 server on the Windows 10 (hosts), however, the performance would be poor due to lack of audio or hardware acceleration. There are lots of advantages of WSL too, such as the user don't need to install any Virtual machine to test out Linux application; one can install and create Apache ( LAMP stack), Nginx kind of web server natively on Windows 10; different types of Linux distributions systems available as apps such as Debian, Ubuntu, Kali Linux and OpenSuse; Consume low resources as compared to Virtual machines; navigate around the file system; use of command line Linux apps via Bash and more… Now let's see how to install Windows subsystem for Linux on Windows 10 or Windows server 2019. The WSL is not available for older versions of Windows. Enable Windows Subsystem for Linux ( WSL ) on Windows 10 Open Control Panel Click on Programs option Select the Turn Windows features Turn on or off Scroll down and find Windows SubSystem for Linux When it appears to select its checkbox and click on the OK button. In a few minutes, the Windows Subsystem for Linux ( WSL ) will automatically get installed on the system. After installation, click the Restart Now button. Now open Microsoft Windows store and search for Linux Install any of the available open-source Linux apps on Windows 10 Step by step installation with screenshots Step 1 : Click on the Start menu of Windows and navigate to open the control panel. Step 2 : From the Control Panel, first click on the \"Turn Windows features on or off\" option. One can also search directly for it from the Search box of Windows. Step 3 : Scroll down and you will find an option Windows Subsystem for Linux. A box is given in front of that click on that to check and then the OK button to install the WSL on Windows 10. Step 4 : When it asks to restart the system do that. Step 5 : After the installation, go to the Microsoft store and download the Linux app to play with. Step 6 : When you search for the term Linux: Run Linux of Windows, Debian, Ubuntu, OpenSuse enterprise server, Kali Linux environments will appear. Choose the one you want to work with to download and install. Here we are installing Ubuntu 18.04. Step 7 : Once we installed Ubuntu or other Linux apps on Windows then just go to search box and type its name. For example, we have installed Ubuntu, so we typed Ubuntu. Step 8 : As soon as you open the bash of Ubuntu on Windows you can run the native Linux commands directly on Windows 10 systems. You can now setup Apache ( LAMP ) web server without the need of WAMP or XAMPP like servers. All the files of the Linux apps will save on your C Drive without any contradiction with Windows files. We tried to set up Apache and PHP on Ubuntu on Windows 10 subsystem for Linux and it worked perfectly. It was smooth and performed better than installing a virtual machine using VirtualBox or other Virtualization software. So, in this way, anyone can enable the subsystem for Linux on Windows to test different Linux commands without compromising much on hardware resources. Use PowerShell command to Install WSL 原文： Windows Subsystem for Linux Installation Guide for Windows 10 Install the Windows Subsystem for Linux Before installing any Linux distros for WSL , you must ensure that the \"Windows Subsystem for Linux\" optional feature is enabled: Open PowerShell as Administrator and run: Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux Restart your computer when prompted.","tags":"Windows","url":"https://doobom.me/enable-windows-subsystem-linux-feature","loc":"https://doobom.me/enable-windows-subsystem-linux-feature"},{"title":"How to Install and Configure Askbot with Nginx on CentOS 7","text":"原文: How to Install and Configure Askbot with Nginx on CentOS 7 Askbot is an open source software for creating Q&A forums based on Python Django Framework. It's basically a Q&A system like StackOverflow, Yahoo Answers, and others. Created by Mike Chan and Sailing Cai on 2009, and it's easy to install and configure on Linux systems like Ubuntu and CentOS. Many large open source software projects like Fedora and LibreOffice are using it. In this tutorial, we will show you how to install Askbot Python Django application using uWSGI and Nginx web server on CentOS 7 system. As for database, we will be using PostgreSQL for Askbot installation. What we will do Install dependencies Install and configure PostgreSQL Install and configure Askbot Install and configure uWSGI Install and configure Nginx Webserver Test the setup Prerequisites CentOS 7 Server Root privileges Step 1 - Install dependencies In this step, we will install some packages that are needed for successful Askbot installation. These include ‘Development Tools', Epel repository, and some python-related tools (for managing Python packages). So let's begin. First, install CentOS ‘Development Tools' with yum group command below. yum group install 'Development Tools' Then install the Epel repository. yum -y install epel-release And finally install the python packages, including python pip, python-devel and python six. yum -y install python-pip python-devel python-six Step 2 - Install and configure PostgreSQL Now we need PostgreSQL database, which is available in the CentOS repository. In this section, we will discuss how you can install PostgreSQL database, change the postgres password user, create a new user and database for the Askbot installation, and finally, change the postgres authentication config. So let's start with installing PostgreSQL from the repository using the yum command below. yum -y install postgresql-server postgresql-devel postgresql-contrib Once the installation is complete, we need to initialize the database, which you can do using the command below. postgresql-setup initdb Moving on, start postgres and enable it to launch automatically at the boot time. systemctl start postgresql systemctl enable postgresql At this point, the PostgreSQL database should be installed. Next, we need to reset the postgres user password. For this, first login as ‘postgres' user and access the psql command line tool. su - postgres psql And then give the postgres user a new password. \\p assword postgres Now, create a new database and user for Askbot. For example, we want to create a new user ‘ hakaselabs ‘ with password ‘ hakase123 ‘, and the database named ‘ askbotdb ‘. The following postgres queries will help us create all of these. create database askbotdb ; create user hakaselabs with password 'hakase123' ; grant all privileges on database askbotdb to hakaselabs ; So now, a database and user for Askbot installation have been created. The next step is to edit the postgres configuration for authentication setup, which you can do by heading to the ‘pgsql/data' directory and editing the ‘pg_hba.conf' file with vim. cd /var/lib/pgsql/data/ vim pg_hba.conf Once inside the file, change all authentication to md5, as shown below. local all all md5 # IPv4 local connections: host all all 127.0.0.1/32 md5 # IPv6 local connections: host all all ::1/128 md5 Now, save and exit the file, and then restart the postgres service. systemctl restart postgresql So by now, the PostgreSQL database has been installed; database for the Askbot installation has been created; and the postgres user authentication method has been changed to md5. Step 3 - Install and configure Askbot In this step, we will discuss the installation and configuration of Askbot. We will install Askbot under a user named ‘askbot', and using the virtualenv python. So let's begin. Firstly, create a new user ‘askbot' and give the user a new password. useradd -m -s /bin/bash askbot passwd askbot Then add the ‘askbot' user to the ‘wheel' group for sudo command access (not sure what ‘sudo' is? Learn more about it here ). usermod -a -G wheel askbot Now upgrade pip to the latest version and install the python virtualenv package. pip install --upgrade pip pip install virtualenv six Next. log in as ‘askbot' user and create new python virtual environment ‘hakase-labs' with virtualenv. su - askbot virtualenv hakase-labs/ Go to the ‘hakase-labs' directory and activate the virtual environment for Askbot installation. cd hakase-labs/ source bin/activate Now install askbot and other python packages with pip command on ‘hakase-labs' virtual environment. pip install six pip install askbot psycopg2 Next, create a new directory for the ‘Askbot' project. Please make sure you don't use ‘askbot' as the directory name. In our case, for example, we created a new directory named ‘myapp' mkdir myapp/ Go to the myapp directory and run the ‘askbot-setup' command. cd myapp/ askbot-setup The ‘askbot-setup' command will ask you certain things. For example, you will be asked about directory path to deploy Askbot - you can type ‘.' and press Enter to continue. Similarly, when asked about database engine, type ‘1' to use postgresql and press Enter. For database-related details, enter databasename as ‘askbotdb', database user as ‘hakaselabs', and password as ‘hakase123'. So Askbot is now installed on the ‘myapp' directory. Now we need to generate Askbot Django static files and the database. Run the command below to generate Askbot Django static files. python manage.py collectstatic When asked for confirmation, type ‘yes' and press Enter. Now, to generate the database, run syncdb as below. python manage.py syncdb You will be asked about creating the admin user and password. So when asked, type the username, email, and password for admin configuration. So by now, Askbot has been installed, static files have been generated, and the database configuration has been completed. You can test the Askbot installation with runserver command below. python manage.py runserver 0 .0.0.0:8080 Open your Web browser and type the server IP address, and you should see a page similar to the following: Step 4 - Install and configure uWSGI We will be using uWSGI as service for the Askbot Django project. Specifically, we will be using uWSGI with Nginx web server for the Askbot installation. So let's begin. Firstly, install uWSGI using the pip command, as shown below. sudo pip install uwsgi After the installation is complete, create a new directory for the uWSGI virtual host files. For example, in our case, we created ‘/etc/uwsgi/sites'. mkdir -p /etc/uwsgi/sites Go to the newly-created directory and create new askbot uWSGI configuration with vim. cd /etc/uwsgi/sites vim askbot.ini Paste the following configuration in the file. [uwsgi] # Project directory, Python directory chdir = /home/askbot/hakase-labs/myapp home = /home/askbot/hakase-labs/ static-map = /m=/home/askbot/hakase-labs/myapp/static wsgi-file = /home/askbot/hakase-labs/myapp/django.wsgi master = true processes = 5 # Askbot will running under the sock file socket = /run/uwsgi/askbot.sock chmod-socket = 664 uid = askbot gid = nginx vacuum = true # uWSGI Log file logto = /var/log/uwsgi.log That's it. Save the file and exit from the editor. Next, add new uWSGI service script file to the ‘/etc/systemd/system' directory. Go to the directory and create the ‘uwsgi.service' file with vim. cd /etc/systemd/system/ vim uwsgi.service Paste the following uWSGI service configuration in the file. [Unit] Description = uWSGI Emperor service [Service] ExecStartPre = /bin/bash -c 'mkdir -p /run/uwsgi; chown askbot:nginx /run/uwsgi' ExecStart=/bin/uwsgi --emperor /etc/uwsgi/sites Restart=always KillSignal=SIGQUIT Type=notify NotifyAccess=all [Install] WantedBy = multi-user.target Save and exit. Now, reload systemd services and enable uWSGI to start automatically at the boot time. systemctl daemon-reload systemctl enable uwsgi So with this, uWSGI has been installed, and you should see it running as a service. Step 5 - Install and configure Nginx webserver So, Askbot is now installed, and it's running under uWSGI sock file ‘askbot.sock'. In this step, we will be using Nginx web server as a reverse proxy for uWSGI application ‘Askbot'. To begin with, install Nginx with the yum command. yum -y install nginx Now go to the Nginx ‘conf.d' directory and create new virtual host file ‘askbot.conf' with the vim editor. cd /etc/nginx/conf.d/ vim askbot.conf Paste the following Askbot Nginx configuration in the file. server { listen 80; server_name askbot.me www.askbot.me; location / { include uwsgi_params; uwsgi_pass unix:/run/uwsgi/askbot.sock; } } Save the file and exit from the editor. Now, test the configuration to make sure there is no error. nginx -t Next, start Nginx and uWSGI services. systemctl start nginx systemctl start uwsgi And enable them to start automatically at the boot time. systemctl enable nginx systemctl enable uwsgi So Nginx is now installed as a reverse proxy for uWSGI application ‘Askbot'. Step 6 - Test the setup Open your web browser and visit the Askbot domain name: askbot.me, and you will get to see the home page, as shown below. Here's the Askbot user login page: Askbot user dashboard: Askbot admin setting: Askbot Django admin login: Askbot Django admin dashboard: So the Q&A system application ‘Askbot' has been successfully installed with uWSGI and Nginx web server on CentOS 7 server. Reference https://askbot.org/en/","tags":"Linux","url":"https://doobom.me/how-to-install-and-configure-askbot-with-nginx-on-centos-7","loc":"https://doobom.me/how-to-install-and-configure-askbot-with-nginx-on-centos-7"},{"title":"git ssh 配置","text":"添加用户名及邮箱到 git 的全局配置 git config --global user.name \"Your Name Here\" # Sets the default name for git to use when you commit git config --global user.email \"your_email@example.com\" # Sets the default email for git to use when you commit 生成 ssh 密钥文件（已有证书就忽略 1. 邮箱改成你的 github 邮件，根据提示操作创建密钥 ssh-keygen -t rsa -b 4096 -C \"your_email@example.com\" 2. 提示 nter a file in which to save the key, 输入文件保存的路径，直接回车就保存到提示的目录 Enter a file in which to save the key ( /c/Users/you/.ssh/id_rsa ) : [ Press enter ] 3. 如果需要添加密码就在出现下面提示时输入 Enter passphrase ( empty for no passphrase ) : [ Type a passphrase ] Enter same passphrase again: [ Type passphrase again ] 设置 ssh 1. 修改 /etc/ssh/ssh_config , 在文件末尾添加 Host github.com User git Hostname github.com IdentityFile /etc/ssh/github-ecdsa-521 2. 将公钥添加到 github 帐户 复制公钥文件到剪贴板 clip < /etc/ssh/github-ecdsa-521.pub # Copies the contents of the id_rsa.pub file to your clipboard 然后点击 你的头像 -> Setting -> SSH and GPG keys -> New SSH key -> 取个名字，粘贴上公钥 -> Add SSH key 3. 用命令测试一下 ssh -T git@github.com 如果提示信息里面能看到你的用户名就说明成功了 参考 GitHub Help -= 完 =-","tags":"git","url":"https://doobom.me/git-auth-via-ssh-key","loc":"https://doobom.me/git-auth-via-ssh-key"},{"title":"Nginx 配置跨域请求 Access-Control-Allow-Origin *","text":"原文: https://segmentfault.com/a/1190000012550346 作者: Developer 本作品系 原作者原创 ， 采用 《署名-非商业性使用-禁止演绎 4.0 国际》许可协议 当出现 403 跨域错误的时候 No 'Access-Control-Allow-Origin' header is present on the requested resource ，需要给 Nginx 服务器配置响应的 header 参数： 一、 解决方案 只需要在Nginx的配置文件中配置以下参数： location / { add_header Access - Control - Allow - Origin * ; add_header Access - Control - Allow - Methods 'GET, POST, OPTIONS' ; add_header Access - Control - Allow - Headers 'DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization' ; if ( $ request_method = 'OPTIONS' ) { return 204 ; } } 上面配置代码即可解决问题了，不想深入研究的，看到这里就可以啦=-= 二、 解释 1. Access-Control-Allow-Origin 服务器默认是不被允许跨域的。给 Nginx 服务器配置 Access-Control-Allow-Origin * 后，表示服务器可以接受所有的请求源（Origin）,即接受所有跨域的请求。 2. Access-Control-Allow-Headers 是为了防止出现以下错误： Request header field Content-Type is not allowed by Access-Control-Allow-Headers in preflight response. 这个错误表示当前请求 Content-Type 的值不被支持。其实是我们发起了 application/json 的类型请求导致的。这里涉及到一个概念：预检请求（preflight request）,请看下面\"预检请求\"的介绍。 3. Access-Control-Allow-Methods 是为了防止出现以下错误： Content-Type is not allowed by Access-Control-Allow-Headers in preflight response. 4.给 OPTIONS 添加 204 的返回，是为了处理在发送 POST 请求时 Nginx 依然拒绝访问的错误 发送\"预检请求\"时，需要用到方法 OPTIONS ,所以服务器需要允许该方法。 三、 预检请求（preflight request） 其实上面的配置涉及到了一个 W3C 标准： CROS ,全称是跨域资源共享 (Cross-origin resource sharing)，它的提出就是为了解决跨域请求的。 跨域资源共享( CORS )标准新增了一组 HTTP 首部字段，允许服务器声明哪些源站有权限访问哪些资源。另外，规范要求， 对那些可能对服务器数据产生副作用的HTTP 请求方法（特别是 GET 以外的 HTTP 请求，或者搭配某些 MIME 类型的 POST 请求） ，浏览器必须首先使用 OPTIONS 方法发起一个预检请求（preflight request），从而获知服务端是否允许该跨域请求。服务器确认允许之后，才发起实际的 HTTP 请求。在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证（包括 Cookies 和 HTTP 认证相关数据）。 其实 Content-Type 字段的类型为 application/json 的请求就是上面所说的搭配某些 MIME 类型的 POST 请求, CORS 规定， Content-Type 不属于以下 MIME 类型的，都属于预检请求： application/x-www-form-urlencoded multipart/form-data text/plain 所以 application/json 的请求 会在正式通信之前，增加一次\"预检\"请求，这次\"预检\"请求会带上头部信息 Access-Control-Request-Headers: Content-Type ： OPTIONS /api/test HTTP/1.1 Origin: http://foo.example Access-Control-Request-Method: POST Access-Control-Request-Headers: Content-Type ... 省略了一些 服务器回应时，返回的头部信息如果不包含 Access-Control-Allow-Headers: Content-Type 则表示不接受非默认的的 Content-Type 。即出现以下错误： Request header field Content-Type is not allowed by Access-Control-Allow-Headers in preflight response. 参考文章： 阮一峰【跨域资源共享 CORS 详解】 MDN web docs【HTTP访问控制（ CORS ）】","tags":"nginx","url":"https://doobom.me/nginx-access-control-allow-origin","loc":"https://doobom.me/nginx-access-control-allow-origin"},{"title":"MariaDB 主从数据库同步","text":"环境： OS : CentOS 7.4 x64 DB : MariaDB 5.5.56 服务端新建一个用于同步的用户： MariaDB [( none )] > GRANT FILE, REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO 'sync_account' @ '%' IDENTIFIED BY '123456' ; 修改服务端 my.cnf 配置文件： server-id = 1 #Server标识, 不能重复 log-bin = mysql-bin #日志文件名 auto_increment_increment=2 #自动增长的步长 解决多个主机自动增长出现重复问题 这个主机使用奇数值 另外一个主机使用偶数值 auto_increment_offset=1 #自动增长的起始数值 binlog-do-db=testdb #指定需要日志的数据库，多个加一行，不需要就注释 binlog-ignore-db = db_name #指定不需要日志的数据库，多个加一行，不需要就注释 replicate-do-db = testdb #指定从端需要同步的数据库，多个加一行，不需要就注释 重启 MariaDB: service mariadb restart 配置过程中为了防止突然的主机数据写入 导致配置主从失败 可以将机器锁定只允许读 注意千万不要将从机配成锁定 否则无法同步数据了 MariaDB [( none )] > FLUSH TABLES WITH READ LOCK ; 配置完从端解锁： MariaDB [( none )] > UNLOCK TABLES ; 备份数据库： mysql -u root -p --quick --all-databases --flush-logs --delete-master-logs --single-transaction > sync.sql 查看服务端状态 MariaDB [( none )] > SHOW MASTER STATUS ; 显示类似如下： +------------------+----------+-------------------------------------+------------------+ | File | Position | Binlog_Do_DB | Binlog_Ignore_DB | +------------------+----------+-------------------------------------+------------------+ | mysql-bin.000013 | 1714336 | testdb | | +------------------+----------+-------------------------------------+------------------+ 1 row in set ( 0 .00 sec ) 从端导入数据库 mysql -u root -p < sync.sql 修改从端 my.cnf 配置文件： server-id = 2 auto_increment_increment=3 auto_increment_offset=1 #其余项目与服务端一致就可以了, 完了重启 MariaDB 配置从端主服务器信息： MariaDB [( none )] > CHANGE MASTER TO MASTER_HOST = 'master.host.name' , \\ #主服务器主机名称 -> MASTER_USER = 'sync_account' , \\ #用于复制的用户 -> MASTER_PASSWORD = '12345' , \\ #复制用户的密码 -> MASTER_PORT = 3306 , \\ #连接使用的端口 -> MASTER_LOG_FILE = 'mysql-bin.000013' , \\ #起点日志文件 -> MASTER_LOG_POS = 1714336 , \\ #起点位置 -> MASTER_CONNECT_RETRY = 10 , \\ #连接重试间隔 -> MASTER_HEARTBEAT_PERIOD = 2 ; #心跳间隔时间 启动从端数据库同步 MariaDB [( none )] > START SLAVE ; #启动同步进程 查看同步信息 MariaDB [( none )] > SHOW SLAVE STATUS \\G #查看从服务器线程的关键参数的信息 *************************** 1 . row *************************** Slave_IO_State: Waiting for master to send event Master_Host: master Master_User: backup1 #被用于连接主服务器的当前用户 Master_Port: 3306 Connect_Retry: 10 #连接重试间隔 Master_Log_File: mysql-bin.000003 #I/O线程当前正在读取的主服务器二进制日志文件的名称 Read_Master_Log_Pos: 1832 #在当前的主服务器二进制日志中，I/O线程已经读取的位置 Relay_Log_File: relay-bin.000003 #SQL线程当前正在读取和执行的中继日志文件的名称 Relay_Log_Pos: 529 #在当前的中继日志中，SQL线程已读取和执行的位置 Relay_Master_Log_File: mysql-bin.000003 #由SQL线程执行的包含多数近期事件的主服务器二进制日志文件的名称 Slave_IO_Running: Yes #I/O线程是否被启动并成功地连接到主服务器上 Slave_SQL_Running: Yes #SQL线程是否被启动 ... Master_Server_Id: 2 查看从端 MASTER 状态，然后在主端启动服务器同步就可以实现相互同步了。 参考： MySQL数据库设置主从同步 实现两个Mysql数据库之间的主从同步 mariadb配置双主多从 MariaDB主从同步 MySQL Documentation","tags":"MySQL","url":"https://doobom.me/mariadb-master-slave-server-sync","loc":"https://doobom.me/mariadb-master-slave-server-sync"},{"title":"使用 grep/sed/awk 提取字符串","text":"原文: http://curryhuang.com/2015/07/18/extract-string-by-grep-sed-awk/ 最近需要对日志进行分析，顺便学习了一下以前一直都没弄得太明白的awk和sed。 任务描述 日志是一个 tsv 文件，这里以 sample.log 为例，每一行大致长成下面这样，需要查看某个 api 的最长 10 次查询时间。根据记录格式，需要提取最后一个字段 ts= 之后的字符串，然后进行排序，排序和求 top 比较容易， sort -nr | head -n 10 即可，比较麻烦的是从字符串中提取数字。 [ 2015 -07-18 11 :00:01,807 ] \\t [ service_name ] \\t [ INFO ] \\t [ 172 .0.0.1 ] \\t [ api/mock_api1 ] \\t [ ts = 239 ] 解决方案 Google 了一番以后，发现 grep/sed/awk 均可以，下面分别说一下每一种方案。 以下方案均在CentOS6上测试通过 grep grep \"api/mock_api1\" sample.log | \\ grep -Eo '\\[ts=[0-9]+\\]' | \\ grep -Eo '[0-9]+' grep 参数说明： E 使用正则表达式 o 只返回匹配的部分 分两部匹配，第一步提取出 [ts=xxxx] ，第二步提取出数字 sed grep \"api/mock_api1\" sample.log | \\ grep -Eo '\\[ts=[0-9]+\\]' | \\ sed -r 's/\\[ts=([0-9]+)\\]/\\1/g' sed参数说明： r 使用正则表达式 使用 sed 也需要通过 grep 先匹配出最后一个字段，再使用 sed 提取数字部分， \\1 表示正则表达式中的分组1 gawk grep \"api/mock_api1\" sample.log | \\ gawk -F '\\t' 'match($6, /\\[ts=([0-9]+)\\]/, arr) { print arr[1] }' gawk 参数说明： F 指定分隔符，这里指定为tab match 的函数参数分别为：待匹配字符串，模式，匹配后的字符串分组 awk 比较强大，可以直接提取出字段信息，这里使用的是 gawk ， gawk 兼容 awk 语法，经测试，同样的语法 awk 无法满足需求，应该是 gawk 和 awk 实现有细微区别。 总结 如果仅仅是提取一个字段信息，三个工具都可以满足需求，相比起来，awk的功能更强大，完成字符串提取， grep 和 sed 的能力更多依赖正则表达式，如果需要同时处理一行记录中的多个字段，比如找出访问请求最长的 10 个 ip， grep 和 sed 就需要很复杂的正则表达式去匹配。","tags":"Shell","url":"https://doobom.me/get-string-in-shell-via-grep-sed-awk","loc":"https://doobom.me/get-string-in-shell-via-grep-sed-awk"},{"title":"如何用 js 准确获取当前页面url网址信息","text":"原文： https://blog.csdn.net/voke_/article/details/78293076 在 WEB 开发中，时常会用到 javascript 来获取当前页面的 url 网址信息，在这里是我的一些获取 url 信息的小总结。 下面我们举例一个 URL ，然后获得它的各个组成部分：http://i.cnblogs.com/EditPosts.aspx?opt=1 1、window.location.href(设置或获取整个 URL 为字符串) var test = window . location . href ; alert ( test ); //返回：http://i.cnblogs.com/EditPosts.aspx?opt=1 2、window.location.protocol(设置或获取 URL 的协议部分) var test = window . location . protocol ; alert ( test ); //返回：http: 3、window.location.host(设置或获取 URL 的主机部分) var test = window . location . host ; alert ( test ); //返回：i.cnblogs.com 4、window.location.port(设置或获取与 URL 关联的端口号码) var test = window . location . port ; alert ( test ); //返回：空字符(如果采用默认的80端口(update:即使添加了:80)，那么返回值并不是默认的80而是空字符) 5、window.location.pathname(设置或获取与 URL 的路径部分（就是文件地址）) var test = window . location . pathname ; alert ( test ); //返回：/EditPosts.aspx 6、window.location.search(设置或获取 href 属性中跟在问号后面的部分) var test = window . location . search ; alert ( test ); //返回：?opt=1 PS ：获得查询（参数）部分，除了给动态语言赋值以外，我们同样可以给静态页面，并使用 javascript 来获得相信应的参数值。 7、window.location.hash(设置或获取 href 属性中在井号\"#\"后面的分段) var test = window . location . hash ; alert ( test ); //返回：空字符(因为url中没有) 8、js获取url中的参数值 一、正则法 function getQueryString ( name ) { var reg = new RegExp ( '(&#94;|&)' + name + '=([&#94;&]*)(&|$)' , 'i' ); var r = window . location . search . substr ( 1 ). match ( reg ); if ( r != null ) { return unescape ( r [ 2 ]); } return null ; } // 这样调用： alert ( GetQueryString ( \"参数名1\" )); alert ( GetQueryString ( \"参数名2\" )); alert ( GetQueryString ( \"参数名3\" )); 二、split拆分法 function GetRequest () { var url = location . search ; //获取url中\"?\"符后的字串 var theRequest = new Object (); if ( url . indexOf ( \"?\" ) != - 1 ) { var str = url . substr ( 1 ); strs = str . split ( \"&\" ); for ( var i = 0 ; i < strs . length ; i ++ ) { theRequest [ strs [ i ]. split ( \"=\" )[ 0 ]] = unescape ( strs [ i ]. split ( \"=\" )[ 1 ]); } } return theRequest ; } var Request = new Object (); Request = GetRequest (); < br > // var id=Request[\"id\"]; // var 参数1,参数2,参数3,参数N; // 参数1 = Request['参数1']; // 参数2 = Request['参数2']; // 参数3 = Request['参数3']; // 参数N = Request['参数N']; 三、指定取 比如说一个 url：http://i.cnblogs.com/?j=js ,我们想得到参数j的值，可以通过以下函数调用。 function GetQueryString ( name ) { var reg = new RegExp ( \"(&#94;|&)\" + name + \"=([&#94;&]*)(&|$)\" , \"i\" ); var r = window . location . search . substr ( 1 ). match ( reg ); //获取url中\"?\"符后的字符串并正则匹配 var context = \"\" ; if ( r != null ) context = r [ 2 ]; reg = null ; r = null ; return context == null || context == \"\" || context == \"undefined\" ? \"\" : context ; } alert ( GetQueryString ( \"j\" )); 四、单个参数的获取方法 function GetRequest () { var url = location . search ; //获取url中\"?\"符后的字串 if ( url . indexOf ( \"?\" ) != - 1 ) { //判断是否有参数 var str = url . substr ( 1 ); //从第一个字符开始 因为第0个是?号 获取所有除问号的所有符串 strs = str . split ( \"=\" ); //用等号进行分隔 （因为知道只有一个参数 所以直接用等号进分隔 如果有多个参数 要用&号分隔 再用等号进行分隔） alert ( strs [ 1 ]); //直接弹出第一个参数 （如果有多个参数 还要进行循环的） } } 以上就是本文的全部内容，希望对大家理解如何获取当前页面 url 网址信息有所帮助。 -= END =-","tags":"Javascript","url":"https://doobom.me/get-url-info-via-javascript","loc":"https://doobom.me/get-url-info-via-javascript"},{"title":"LINUX 暂停、继续进程","text":"原文： https://www.cnblogs.com/mfryf/archive/2012/09/24/2700042.html kill -STOP 1234 将该进程暂停。 如果要让它恢复到后台，用 kill -CONT 1234 （很多在前台运行的程序这样是不行的） 如果要恢复到前台，请在当时运行该进程的那个终端用 jobs 命令查询暂停的进程。 然后用 fg 〔job号〕 把进程恢复到前台。 如果 jobs 只查询到一个进程，只用 fg 即可。 例： root@dWorks:~# bc -q [ 1 ] + Stopped bc -q root@dWorks:~# bc -q [ 2 ] + Stopped bc -q root@dWorks:~# jobs [ 1 ] - Stopped bc -q [ 2 ] + Stopped bc -q root@dWorks:~# fg 2 bc -q 1 +1 2 A. Shell 支持作用控制，有以下命令： command& 让进程在后台运行 jobs 查看后台运行的进程 fg %n 让后台运行的进程n到前台来 bg %n 让进程 n 到后台去； PS :\"n\"为 jobs 查看到的进程编号. B.下列转:http://blog.chinaunix.net/u/1604/showart_1079559.html fg 、 bg 、 jobs 、&、 ctrl + z 都是跟系统任务有关的，虽然现在基本上不怎么需要用到这些命令，但学会了也是很实用的 一。 & 最经常被用到 这个用在一个命令的最后，可以把这个命令放到后台执行 二。 ctrl + z 可以将一个正在前台执行的命令放到后台，并且暂停 三。 jobs 查看当前有多少在后台运行的命令 四。 fg 将后台中的命令调至前台继续运行 如果后台中有多个命令，可以用 fg %jobnumber 将选中的命令调出， %jobnumber 是通过 jobs 命令查到的后台正在执行的命令的序号(不是pid) 五。 bg 将一个在后台暂停的命令，变成继续执行 如果后台中有多个命令，可以用 bg %jobnumber 将选中的命令调出， %jobnumber 是通过 jobs 命令查到的后台正在执行的命令的序号(不是pid) Linux下使用Shell命令控制任务Jobs执行 下列命令可以用来操纵进程任务： ps 列出系统中正在运行的进程； kill 发送信号给一个或多个进程（经常用来杀死一个进程）； jobs 列出当前 shell 环境中已启动的任务状态，若未指定 jobsid，则显示所有活动的任务状态信息；如果报告了一个任务的终止(即任务的状态被标记为 Terminated)，shell 从当前的 shell 环境已知的列表中删除任务的进程标识； bg 将进程搬到后台运行（Background）； fg 将进程搬到前台运行（Foreground）； 将 job 转移到后台运行 如果你经常在X图形下工作，你可能有这样的经历：通过终端命令运行一个 GUI 程序， GUI 界面出来了，但是你的终端还停留在原地，你不能在 shell 中继续执行其他命令了，除非将 GUI 程序关掉。 为了使程序执行后终端还能继续接受命令，你可以将进程移到后台运行，使用如下命令运行程序： #假设要运行xmms $xmms & 这样打开 xmms 后，终端的提示又回来了。现在 xmms 在后台运行着呢；但万一你运行程序时忘记使用 \"&\" 了，又不想重新执行；你可以先使用 ctrl+z 挂起程序，然后敲入 bg 命令，这样程序就在后台继续运行了。 概念：当前任务 如果后台的任务号有2个，[1],[2]；如果当第一个后台任务顺利执行完毕，第二个后台任务还在执行中时，当前任务便会自动变成后台任务号码\"[2]\"的后台任务。所以可以得出一点，即当前任务是会变动的。当用户输入 fg 、 bg 和 stop 等命令时，如果不加任何引号，则所变动的均是当前任务。 察看 jobs 使用 jobs 或 ps 命令可以察看正在执行的 jobs。 jobs 命令执行的结果， ＋ 表示是一个当前的作业， - 表是是一个当前作业之后的一个作业， jobs -l 选项可显示所有任务的 PID , jobs 的状态可以是 running, stopped, Terminated,但是如果任务被终止了（kill），shell 从当前的 shell 环境已知的列表中删除任务的进程标识；也就是说，jobs 命令显示的是当前shell环境中所起的后台正在运行或者被挂起的任务信息； 进程的挂起 后台进程的挂起： 在 solaris 中通过 stop 命令执行，通过 jobs 命令查看 job 号(假设为 num)，然后执行 stop %num ； 在 redhat 中，不存在 stop 命令，可通过执行命令 kill -stop PID ，将进程挂起； 当要重新执行当前被挂起的任务时，通过 bg %num 即可将挂起的 job 的状态由 stopped 改为running，仍在后台执行；当需要改为在前台执行时，执行命令 fg %num 即可； 前台进程的挂起： ctrl+Z 进程的终止 后台进程的终止： 方法一： 通过 jobs 命令查看 job 号（假设为 num ），然后执行 kill %num 方法二： 通过 ps 命令查看 job 的进程号（ PID ，假设为pid），然后执行 kill pid 前台进程的终止： ctrl+c kill的其他作用 kill 除了可以终止进程，还能给进程发送其它信号，使用 kill -l 可以察看 kill 支持的信号。 SIGTERM 是不带参数时 kill 发送的信号，意思是要进程终止运行，但执行与否还得看进程是否支持。如果进程还没有终止，可以使用 kill -SIGKILL pid ，这是由内核来终止进程，进程不能监听这个信号。 Unix/Linux 下一般想让某个程序在后台运行，很多都是使用 & 在程序结尾来让程序自动运行。比如我们要运行mysql在后台： /usr/local/mysql/bin/mysqld_safe --user = mysql & 但是我们很多程序并不象 mysqld 一样可以做成守护进程，可能我们的程序只是普通程序而已，一般这种程序即使使用 & 结尾，如果终端关闭，那么程序也会被关闭。为了能够后台运行，我们需要使用 nohup 这个命令，比如我们有个 start.sh 需要在后台运行，并且希望在后台能够一直运行，那么就使用 nohup ： nohup /root/start.sh & 在 shell 中回车后提示： [ ~ ] $ appending output to nohup.out 原程序的的标准输出被自动改向到当前目录下的 nohup.out 文件，起到了 log 的作用。 但是有时候在这一步会有问题，当把终端关闭后，进程会自动被关闭，察看 nohup.out 可以看到在关闭终端瞬间服务自动关闭。 咨询红旗 Linux 工程师后，他也不得其解，在我的终端上执行后，他启动的进程竟然在关闭终端后依然运行。 在第二遍给我演示时，我才发现我和他操作终端时的一个细节不同：他是在当 shell 中提示了 nohup 成功后还需要按终端上键盘任意键退回到 shell 输入命令窗口，然后通过在 shell 中输入 exit 来退出终端；而我是每次在 nohup 执行成功后直接点关闭程序按钮关闭终端.。所以这时候会断掉该命令所对应的 session，导致 nohup 对应的进程被通知需要一起 shutdown。 这个细节有人和我一样没注意到，所以在这儿记录一下了。 附：nohup命令参考 nohup 命令 用途：不挂断地运行命令。 语法： nohup Command [ Arg ... ] [ & ] 描述：nohup 命令运行由 Command 参数和任何相关的 Arg 参数指定的命令，忽略所有挂断（ SIGHUP ）信号。在注销后使用 nohup 命令运行后台中的程序。要运行后台中的 nohup 命令，添加 & （表示\"and\"的符号）到命令的尾部。 无论是否将 nohup 命令的输出重定向到终端，输出都将附加到当前目录的 nohup.out 文件中。如果当前目录的 nohup.out 文件不可写，输出重定向到 $HOME/nohup.out 文件中。如果没有文件能创建或打开以用于追加，那么 Command 参数指定的命令不可调用。如果标准错误是一个终端，那么把指定的命令写给标准错误的所有输出作为标准输出重定向到相同的文件描述符。 退出状态：该命令返回下列出口值： 126 可以查找但不能调用 Command 参数指定的命令。 127 nohup 命令发生错误或不能查找由 Command 参数指定的命令。 否则，nohup 命令的退出状态是 Command 参数指定命令的退出状态。 nohup命令及其输出文件 nohup命令：如果你正在运行一个进程，而且你觉得在退出帐户时该进程还不会结束，那么可以使用nohup命令。该命令可以在你退出帐户/关闭终端之后继续运行相应的进程。nohup就是不挂起的意思( n ohang up)。 该命令的一般形式为： nohup command & 使用nohup命令提交作业 如果使用nohup命令提交作业，那么在缺省情况下该作业的所有输出都被重定向到一个名为 nohup.out 的文件中，除非另外指定了输出文件： nohup command > myout.file 2 > & 1 & 在上面的例子中，输出被重定向到 myout.file 文件中。 使用 jobs 查看任务。 使用 fg %n 关闭。 另外有两个常用的 ftp 工具 ncftpget 和 ncftpput ，可以实现后台的 ftp 上传和下载，这样就可以利用这些命令在后台上传和下载文件了。 简单而有用的 nohup 命令在 UNIX / LINUX 中，普通进程用&符号放到后台运行，如果启动该程序的控制台 logout，则该进程随即终止。 要实现守护进程，一种方法是按守护进程的规则去编程（本站有文章介绍过），比较麻烦；另一种方法是仍然用普通方法编程，然后用nohup命令启动程序： nohup＜程序名＞ & 则控制台logout后，进程仍然继续运行，起到守护进程的作用（虽然它不是严格意义上的守护进程）。 使用nohup命令后，原程序的的标准输出被自动改向到当前目录下的 nohup.out 文件，起到了 log 的作用，实现了完整的守护进程功能。 ygwu @ 2005年04月18日 上午10:03 For example： 如何远程启动 WebLogic 服务? 用 telnet 远程控制服务器，远程启动 WEBLOGIC 服务，启动后关闭 telnet，WebLogic 服务也跟着停止，这是因为使用 telnet 启动的进程会随着 telnet 进程的关闭而关闭。所以我们可以使用一些 UNIX 下的命令来做到不关闭。 使用如下命令： nohup startWeblogic.sh& 如果想要监控标准输出可以使用： tail -f nohup.out 当在后台运行了程序的时候，可以用 jobs 命令来查看后台作业的状态。在有多个后台程序时，要使用来参数的 fg 命令将不同序号的后台作业切换到前台上运行。 当用户启动一个进程的时候，这个进程是运行在前台，使用与相应控制终端相联系的标准输入、输出进行输入和输出。即使将进程的输入输出重定向，并将进程放在后台执行，进程仍然和当前终端设备有关系。正因为如此，在当前的登录会话结束时，控制终端设备将和登录进程相脱离，那么系统就向所有与这个终端相联系的进程发送 SIGHUP 的信号，通知进程线路已经挂起了，如果程序没有接管这个信号的处理，那么缺省的反应是进程结束。因此普通的程序并不能真正脱离登录会话而运行进程，为了使得在系统登录后还可以正常执行，只有使用命令 nohup 来启动相应程序。 使用命令 nohup 当然可以启动这样的程序，但 nohup 启动的程序在进程执行完毕就退出，而常见的一些服务进程通常永久的运行在后台，不向屏幕输出结果。在 Unix 中这些永久的后台进程称为守护进程（daemon）。守护进程通常从系统启动时自动开始执行，系统关闭时才停止。 -=- END -=-","tags":"Linux","url":"https://doobom.me/linux-stop-cont-ps","loc":"https://doobom.me/linux-stop-cont-ps"},{"title":"Telnet 中使用 smtp 发送邮件","text":"原文作者：litreily 原文链接： https://www.litreily.top/2017/08/17/telnet-smtp/ 这两天在折腾 javascript 发送邮件的事情, 然后就看到了这个. Telnet是远程登录服务的标准协议和主要方式，工作于TCP/IP协议族的应用层，常用于远程登录web服务器，其中便包括SMTP，POP3等邮件服务器。 这几天参考书籍《计算机网络-自顶向下方法》学习计算机网络知识，顺便尝试了如何使用Telnet登录smtp发送邮件，下面通过一个简单示例介绍具体的发送过程。 Telnet smtp.163.com 25 smtp对应的端口号为25，以163邮箱为例，下面是邮件发送过程。 → ~ telnet smtp.163.com 25 Trying 220 .181.12.15... Connected to smtp.163.com. Escape character is &#94; ] . 220 163 .com Anti-spam GT for Coremail System ( 163com [ 20141201 ]) helo 163 .com 250 OK auth login 334 dXNlcm5hbWU6 MTgyNjY2MzI4NzJAMTYzLmNvbQ == 334 UGFzc3dvcmQ6 **************** 235 Authentication successful mail from:< 182 ****2872@163.com> 250 Mail OK rcpt to:< 707 ***098@qq.com> 250 Mail OK data 354 End data with <CR><LF>.<CR><LF> From: 182 ****2872@163.com To: 707 ***098@qq.com Subject: Test the use of smtp Hello, litreily. This is a message edit with telnet. Best wish to you. Litreily . 250 Mail OK queued as smtp11,D8CowAAnjlqKlZVZXa4QAQ--.18342S2 1502975693 quit Connection closed by foreign host. → ~ 下面分开对每个过程进行解析，C代表客户端，即本机，S代表远程服务器端。整个过程分为以下几步： * 打招呼 * 账户认证 * 声明邮箱地址 * 书写邮件内容 * 退出Telnet 招呼语 S 220 163 .com Anti-spam GT for Coremail System ( 163com [ 20141201 ]) C helo 163 .com S 250 OK 220 代表服务器已准备好，客户端首先向服务器打一声招呼 helo ，服务器接收到后返回一个 250 应答信号，代表打招呼成功，下面可以进行账户的密码认证。 账户认证 C auth login S 334 dXNlcm5hbWU6 C MTgyNjY2MzI4NzJAMTYzLmNvbQ == S 334 UGFzc3dvcmQ6 C **************** S 235 Authentication successful 客户端发送 auth login 声明自己将进行邮箱账户的用户名认证和密码认证。服务器端返回一个以 334 代码开头的提示信息，不必追究其语义，而后用户依次输入通过Base64加密的邮箱名和密码，加密网址见后续参考资料。当输入的账号密码无误时，服务端将返回认证成功的提示语。 声明邮箱地址 C mail from:< 182 ****2872@163.com> S 250 Mail OK C rcpt to:< 707 ***098@qq.com> S 250 Mail OK 账户密码认证结束后，客户端通过 mail from:<emailName> 以及 rcpt to:<nameEmail> 声明邮箱的源地址和目的地址。 书写邮件内容 C data S 354 End data with <CR><LF>.<CR><LF> C From: 182 ****2872@163.com C To: 707 ***098@qq.com C Subject: Test the use of smtp C C Hello, litreily. C This is a message edit with telnet. C C Best wish to you. C Litreily C . S 250 Mail OK queued as smtp11,D8CowAAnjlqKlZVZXa4QAQ--.18342S2 1502975693 写明邮件地址后，使用指令 data 进入邮件编辑状态，服务器端会提示当输入 <CR><LF>.<CR><LF> 时退出编辑状态。 邮件内容有一定的格式要求，不按要求随意书写有可能被当成垃圾邮件或不合法邮件而退信。通常需要指定邮件主题 Subject ，其它相关信息包括时间 Date ，邮件地址 From ， To 等，然后再书写邮件主体内容，更详细的格式可以参考文档【 RFC 821】。编辑结束后，以单行的点号 . 结束。如果一切正常，服务器端将返回以 250 开头的应答信息，并提示邮件以进入smtp的发送队列。此时便可以查收邮件予以验证了。 退出Telnet C quit S Connection closed by foreign host. 当邮件发送结束后，客户端通过 quit 退出Telnet。 SMTP Code 211 系统状态或系统帮助响应 214 帮助信息 220 服务就绪 221 服务关闭传输信道 235 用户验证成功 250 要求的邮件操作完成 251 用户非本地，将转发向 334 等待用户输入验证信息 354 开始邮件输入，以单行.结束 421 服务未就绪，关闭传输信道（当必须关闭时，此应答可以作为对任何命令的响应） 450 要求的邮件操作未完成，邮箱不可用（例如，邮箱忙） 451 放弃要求的操作；处理过程中出错 452 系统存储不足，要求的操作未执行 500 格式错误，命令不可识别（此错误也包括命令行过长） 501 参数格式错误 502 命令不可实现 503 错误的命令序列 504 命令参数不可实现 535 用户验证失败 550 要求的邮件操作未完成，邮箱不可用（例如，邮箱未找到，或不可访问） 551 用户非本地，请尝试 552 过量的存储分配，要求的操作未执行 553 邮箱名不可用，要求的操作未执行（例如邮箱格式错误） 554 操作失败 参考资料 SMTP文档( RFC 821) : https://tools.ietf.org/pdf/rfc821.pdf SMTP Code : http://bbs.csdn.net/topics/80275246 163.com 邮件退信代码 : http://help.163.com/09/1224/17/ 5RAJ4LMH00753VB8 .html","tags":"Shell","url":"https://doobom.me/send-mail-via-smtp-in-telnet","loc":"https://doobom.me/send-mail-via-smtp-in-telnet"},{"title":"JS 数字指定长度不足前补零的实现","text":"原文： https://wsj123.iteye.com/blog/2412696 问题描述： 要求输出的数字长度是固定的，如长度为2，数字为1，则输出01，即不够位数就在之前补足0。 解决方法： 方法1 function fn1 ( num , length ) { return ( num / Math . pow ( 10 , length )). toFixed ( length ). substr ( 2 ); } 方法2 function fn2 ( num , length ) { return ( \"0000000000000000\" + num ). substr ( - length ); } 方法3 function fn3 ( num , length ) { return ( Array ( length ). join ( '0' ) + num ). slice ( - length ); } 上述三种方法的效率如下： console . time ( 'time1' ); fn1 (); console . timeEnd ( 'time1' ); //chrome返回值：time1: 0.126953125ms console . time ( 'time2' ); fn2 (); console . timeEnd ( 'time2' ); //chrome返回值：time2: 0.0810546875ms console . time ( '3' ); fn3 (); console . timeEnd ( 'time3' ); //chrome返回值：time3: 0ms -=- END -=-","tags":"Javascript","url":"https://doobom.me/string-number-to-define-length","loc":"https://doobom.me/string-number-to-define-length"},{"title":"JavaScript 字符串/数字左补位，右补位，取固定长度，截位扩展函数代码","text":"原文： https://www.jb51.net/article/109523.htm 有时候我们的日期等不足两位的补一个0等，都可以使用这个。 这个大家应该都很明白了，就不废话了，代码如下： String . prototype . padLeft = Number . prototype . padLeft = function ( total , pad ) { return ( Array ( total ). join ( pad || 0 ) + this ). slice ( - total ); } 测试代码： //补位 \"X\" . padLeft ( 5 , \"Y\" ); //返回：YYYYX ( 50 ). padLeft ( 5 ); //返回：00050 var x = 1 ; x . padLeft ( 2 ); //返回：01 //截位 ( 123 ). padLeft ( 2 ); //返回：23 更多代码 /** * 取子字符串 * @param oriStr 原字符串 * @param beginIndex 取子串的起始位置 * @param len 取子串的长度 * @return 子字符串 */ public String subString ( String oriStr , int beginIndex , int len ){ int strlen = oriStr . length (); beginIndex = beginIndex - 1 ; if ( strlen <= beginIndex ){ System . out . println ( \"out of \" + oriStr + \"'s length, please recheck!\" ); } else if ( strlen <= beginIndex + len ){ str = oriStr . substring ( beginIndex ); } else { str = oriStr . substring ( beginIndex , beginIndex + len ); } return str ; } /** * 右补位，左对齐 * @param oriStr 原字符串 * @param len 目标字符串长度 * @param alexin 补位字符 * @return 目标字符串 */ public String padRight ( String oriStr , int len , char alexin ){ int strlen = oriStr . length (); if ( strlen < len ){ for ( int i = 0 ; i < len - strlen ; i ++ ){ str = str + alexin ; } } str = str + oriStr ; return str ; } /** * 左补位，右对齐 * @param oriStr 原字符串 * @param len 目标字符串长度 * @param alexin 补位字符 * @return 目标字符串 */ public String padLeft ( String oriStr , int len , char alexin ){ int strlen = oriStr . length (); if ( strlen < len ){ for ( int i = 0 ; i < len - strlen ; i ++ ){ str = str + alexin ; } } str = oriStr + str ; return str ; } -=- END -=-","tags":"Javascript","url":"https://doobom.me/string-number-to-define-length-foo","loc":"https://doobom.me/string-number-to-define-length-foo"},{"title":".gitignore 设置 git 忽略跟踪文件和文件夹","text":"在项目的根目录（跟 .git 文件夹所在目录同层）建立 .gitignore 文件，在里面声明即可。 配置语法 以斜杠\"/\"开头表示目录； 以星号\"*\"通配多个字符； 以问号\"?\"通配单个字符 以方括号\"[]\"包含单个字符的匹配列表； 以叹号\"!\"表示不忽略(跟踪)匹配到的文件或目录。 git 对于 .gitignore 配置文件是按行从上到下进行规则匹配的 如果之前文件已提交过，则需要先清除原文件: git rm *.dll 这样. 另一种方法 修改git的全局设置，把忽略名单用于所有项目： 首先，建立一个 .gitignore_global 文件； git config --global core.excludesfile .gitignore_global 栗子 Github 给出的 Android 开发中使用的 .gitignore 模板 # Built application files * .apk * .ap_ # Files for the Dalvik VM * .dex # Java class files * .class # Generated files bin / gen / out / # Gradle files .gradle / build / # Local configuration file (sdk path, etc) local.properties # Proguard folder generated by Eclipse proguard / # Log Files * .log # Android Studio Navigation editor temp files .navigation / # Android Studio captures folder captures / # Intellij * .iml # Keystore files * .jks 参考 https://github.com/github/gitignore/blob/master/Android.gitignore https://git-scm.com/docs/gitignore https://www.jianshu.com/p/ea6341224e89 https://blog.csdn.net/u011475134/article/details/71521725 -= 完 =-","tags":"git","url":"https://doobom.me/git-set-gitignore","loc":"https://doobom.me/git-set-gitignore"},{"title":"Vim 多文件编辑：缓冲区","text":"原文链接: https://harttle.land/2015/11/17/vim-buffer.html 本文介绍Vim下 缓冲区(Buffer) 的使用. 引用Vim官方解释， 缓冲区 是一个文件的内容占用的那部分Vim内存： A buffer is an area of Vim's memory used to hold text read from a file. In addition, an empty buffer with no associated file can be created to allow the entry of text. –vim.wikia 先来回顾一下Tab，Window，Buffer的关系吧！ 基于缓冲区的多文件编辑是Vim最为推荐的做法，Vim维护着你在当前打开的这些Buffer里的所有跳转， Ctrl+o 和 Ctrl+i 可以遍历这些光标位置（参考： 在Vim中进行快速光标移动 ）。 但一个窗口内只有一个Buffer是处于可见状态的，所以Buffer的用法最不直观。 学习Vim就要克服那些不直观的操作！因为Vim本身就是基于CLI的，而我们相信CLI就是效率。本文便来总结一下Buffer相关的命令与操作。 打开与关闭 不带任何参数打开多个文件便可以把它们都放入缓冲区（Buffer）： vim a .txt b .txt 当你使用 :q 关闭文件时？是否看到过 1 more file to edit 的警告？那就是缓冲区中的文件。 进入Vim后，通过 :e[dit] 命令即可打开某个文件到缓冲区。还记得吗？使用 :new 可以 打开一个新窗口 。 关闭一个文件可以用 :q ，移出缓冲区用 :bd[elete] （占用缓冲区的文件对你毫无影响，多数情况下不需要这样做）。 如果Buffer未保存 :bd 会失败，如果强制删除可以 :bd! 。 缓冲区跳转 缓冲区之间跳转最常用的方式便是 Ctrl+&#94; （不需要按下Shift）来切换当前缓冲区和上一个缓冲区。 另外，还提供了很多跳转命令： : ls , : buffers 列出所有缓冲区 : bn [ext] 下一个缓冲区 : bp [revious] 上一个缓冲区 : b { number , expression} 跳转到指定缓冲区 :b 接受缓冲区编号，或者部分文件名。例如： * :b2 将会跳转到编号为2的缓冲区，如果你正在用 :ls 列出缓冲区，这时只需要输入编号回车即可。 * :b exa 将会跳转到最匹配 exa 的文件名，比如 example.html ， 模糊匹配打开文件正是Vim缓冲区的强大之处 。 分屏 在 Vim 多文件编辑：窗口 中已经介绍了Vim中分割屏幕的操作。 其实分屏时还可以指定一个Buffer在新的Window中打开。 : sb 3 分屏并打开编号为3的Buffer : vertical sb 3 同上，垂直分屏 : vertical rightbelow sfind file .txt 注意 sfind 可以打开在Vim PATH中的任何文件。这当然需要我们设置PATH，一个通用的做法是在 ~/.vimrc 中添加： \" 将当前工作路径设为Vim PATH set path = $PWD/** 利用通配符进行缓冲区跳转 这是缓冲区最强大的功能之一。我们可以使用通配符来指定要跳转到的缓冲区文件名。 在此之前，我们启动 wildmenu 并设置匹配后文件选择模式为 full 。 wildchar 为选择下一个备选文件的快捷键， 而 wildcharm 用于宏定义中（语义同 wildchar ），比如后面的 noremap 。 set wildmenu wildmode = full set wildchar =< Tab > wildcharm =< C - Z > 比如现在按下打开这些文件： vehicle. c vehicle. h car. c car. h jet. c jet. h jetcar. c jetcar. h 然后按下 :b <Tab> 便可看到Vim提供的备选文件列表了， 按下 <Tab> 选择下一个，按下回车打开当前文件。 : b < Tab > \" 显示所有Buffer中的文件 : b car < Tab > \" 显示 car.c car.h : b *car < Tab > \" 显示 car.c jetcar.c car.h jetcar.h : b . h < Tab > \" 显示 vehicle.h car.h jet.h jetcar.h : b . c < Tab > \" 显示 vehicle.c car.c jet.c jetcar.c : b ar . c < Tab > \" 显示 car.c jetcar.c : b j * c < Tab > \" 显示 jet.c jetcar.c jetcar.h 我们可以为 :b <Tab> 设置一个快捷键 <c-n> ，这时便用到上文中设置的 wildcharm 了： noremap < c - n > : b < c - z > -= 完 =-","tags":"VIM","url":"https://doobom.me/use-buffer-edit-multi-files-in-vim","loc":"https://doobom.me/use-buffer-edit-multi-files-in-vim"},{"title":"Vim 多文件编辑：标签页","text":"原文链接: https://harttle.land/2015/11/12/vim-tabpage.html 多文件编辑的场景太常见了：代码比对、项目重构、模块构建… 最初harttle在碰到这些问题时直接转向IDE了，其实Vim不仅支持多文件编辑，而且支持多种风格：标签页(tab)、窗口(window)、缓冲区(buffer)等。 今天harttle就来介绍一下Vim强大的多文件编辑！本文介绍Vim标签页的使用. 要做一个强大的IDE，除了多文件编辑技巧，你可能还需要终端复用和目录树。 打开与关闭 标签页 是最常见的多文件编辑方式吧，熟悉IDE的小伙伴一定能很快上手！ 使用 -p 参数来用多个标签页启动Vim： vim - p main.cpp my - oj - toolkit. h /private/ etc/hosts 在Vim中也可以打开和关闭标签： : tabe [dit] { file } edit specified file in a new tab : tabf [ind] { file } open a new tab with filename given , searching the 'path' to find it : tabc [lose] close current tab : tabc [lose] { i } close i - th tab : tabo [nly] close all other tabs ( show only the current tab ) 中括号中的部分可以省略，在Vim中 :h tabedit 可以查看命令帮助。 移动标签 : tabs list all tabs including their displayed window : tabm 0 move current tab to first : tabm move current tab to last : tabm { i } move current tab to position i + 1 标签跳转 : tabn go to next tab : tabp go to previous tab : tabfirst go to first tab : tablast go to last tab 在正常模式（normal）下，还可以使用快捷键： gt go to next tab gT go to previous tab { i }gt go to tab in position i 可以设置更通用的切换标签页快捷键，比如我的 ~/.vimrc 是这样设置的: noremap < C - L > < Esc > :tabnext < CR > noremap < C - H > < Esc > : tabprevious < CR > -= 完 =-","tags":"VIM","url":"https://doobom.me/use-tagpages-edit-multi-files-in-vim","loc":"https://doobom.me/use-tagpages-edit-multi-files-in-vim"},{"title":"Vim 多文件编辑：窗口","text":"原文链接: https://harttle.land/2015/11/14/vim-window.html 标签页(tab)、窗口(window)、缓冲区(buffer)是Vim多文件编辑的三种方式，它们可以单独使用，也可以同时使用。 它们的关系是这样的： A buffer is the in-memory text of a file. A window is a viewport on a buffer. A tab page is a collection of windows. – vimdoc 本文主要介绍Vim窗口的创建与维护, 先上图： 分屏打开多个文件 使用 -O 参数可以让Vim以分屏的方式打开多个文件： vim - O main.cpp my - oj - toolkit. h 使用小写的-o可以水平分屏。 打开关闭命令 在进入Vim后，可以使用这些命令来打开/关闭窗口： : sp [lit] { file } 水平分屏 : new { file } 水平分屏 : sv [iew] { file } 水平分屏，以只读方式打开 : vs [plit] { file } 垂直分屏 : clo [ se ] 关闭当前窗口 上述命令中，如未指定file则打开当前文件。 打开关闭快捷键 上述命令都有相应的快捷键，它们有共同的前缀： Ctrl+w 。 Ctrl + w s 水平分割当前窗口 Ctrl + w v 垂直分割当前窗口 Ctrl + w q 关闭当前窗口 Ctrl + w n 打开一个新窗口（空文件） Ctrl + w o 关闭出当前窗口之外的所有窗口 Ctrl + w T 当前窗口移动到新标签页 切换窗口 切换窗口的快捷键就是 Ctrl+w 前缀 + hjkl ： Ctrl + w h 切换到左边窗口 Ctrl + w j 切换到下边窗口 Ctrl + w k 切换到上边窗口 Ctrl + w l 切换到右边窗口 Ctrl + w w 遍历切换窗口 还有 t 切换到最上方的窗口， b 切换到最下方的窗口。 移动窗口 分屏后还可以把当前窗口向任何方向移动，只需要将上述快捷键中的 hjkl 大写： Ctrl + w H 向左移动当前窗口 Ctrl + w J 向下移动当前窗口 Ctrl + w K 向上移动当前窗口 Ctrl + w L 向右移动当前窗口 调整大小 调整窗口大小的快捷键仍然有 Ctrl+W 前缀： Ctrl + w + 增加窗口高度 Ctrl + w - 减小窗口高度 Ctrl + w = 统一窗口高度 -= 完 =-","tags":"VIM","url":"https://doobom.me/use-windows-edit-multi-files-in-vim","loc":"https://doobom.me/use-windows-edit-multi-files-in-vim"},{"title":"在 Vim 中优雅地查找和替换","text":"本文来源: https://harttle.land/2016/08/08/vim-search-in-file.html 总有人问我 Vim 中能不能查找，当然能！而且是超级强的查找！ 这篇文章来详细介绍 Vim 中查找相关的设置和使用方法。 包括查找与替换、查找光标所在词、高亮前景/背景色、切换高亮状态、大小写敏感查找等。 查找 在 normal 模式下按下 / 即可进入查找模式，输入要查找的字符串并按下回车。 Vim会跳转到第一个匹配。按下 n 查找下一个，按下 N 查找上一个。 Vim查找支持正则表达式，例如 /vim$ 匹配行尾的\" vim \" 。 需要查找特殊字符需要转义，例如 /vim\\$ 匹配\" vim$ \" 。 注意查找回车应当用 \\n ，而替换为回车应当用 \\r （相当于 <CR> ）。 大小写敏感查找 在查找模式中加入 \\c 表示大小写不敏感查找， \\C 表示大小写敏感查找。例如： /foo\\ c 将会查找所有的\" foo \" ,\" FOO \" ,\" Foo \" 等字符串。 大小写敏感配置 Vim 默认采用大小写敏感的查找，为了方便我们常常将其配置为大小写不敏感： \" 设置默认进行大小写不敏感查找 set ignorecase \" 如果有一个大写字母，则切换到大小写敏感查找 set smartcase 将上述设置粘贴到你的 ~/.vimrc ，重新打开Vim即可生效。 查找当前单词 在 normal 模式下按下 * 即可查找光标所在单词（word）， 要求每次出现的前后为空白字符或标点符号。例如当前为 foo ， 可以匹配 foo bar 中的 foo ，但不可匹配 foobar 中的 foo 。 这在查找函数名、变量名时非常有用。 按下 g* 即可查找光标所在单词的字符序列，每次出现前后字符无要求。 即 foo bar 和 foobar 中的 foo 均可被匹配到。 查找与替换 :s （substitute）命令用来查找和替换字符串。语法如下： : {作用范围}s /{目标}/ {替换}/{替换标志} 例如 :%s/foo/bar/g 会在全局范围( % )查找 foo 并替换为 bar ，所有出现都会被替换（ g ）。 作用范围 作用范围分为当前行、全文、选区等等。 当前行： : s /foo/ bar/ g 全文： : %s /foo/ bar/ g 选区，在Visual模式下选择区域后输入 : ，Vim即可自动补全为 :'<,'> 。 : '<,' > s /foo/ bar/ g 2-11行： : 5 , 12 s /foo/ bar/ g 当前行.与接下来两行+2： : . ,+ 2 s /foo/ bar/ g 替换标志 上文中命令结尾的 g 即是替换标志之一，表示全局 global 替换（即替换目标的所有出现）。 还有很多其他有用的替换标志： 空替换标志表示只替换从光标位置开始，目标的第一次出现： : %s /foo/ bar i 表示大小写不敏感查找， I 表示大小写敏感： : %s /foo/ bar/ i # 等效于模式中的\\ c （不敏感）或\\C（敏感） : %s /foo\\c/ bar c 表示需要确认，例如全局查找\" foo \" 替换为\" bar \" 并且需要确认： : %s /foo/ bar/gc 回车后Vim会将光标移动到每一次\" foo \" 出现的位置，并提示 replace with bar ( y /n/ a /q/ l /&#94;E/ &#94;Y ) ? 按下 y 表示替换， n 表示不替换， a 表示替换所有， q 表示退出查找模式， l 表示替换当前位置并退出。 &#94;E 与 &#94;Y 是光标移动快捷键，参考： Vim中如何快速进行光标移动 。 高亮设置 高亮颜色设置 如果你像我一样觉得高亮的颜色不太舒服，可以在 ~/.vimrc 中进行设置： highlight Search ctermbg = yellow ctermfg = black highlight IncSearch ctermbg = black ctermfg = yellow highlight MatchParen cterm = underline ctermbg = NONE ctermfg = NONE 上述配置指定 Search 结果的前景色（foreground）为黑色，背景色（background）为灰色； 渐进搜索的前景色为黑色，背景色为黄色；光标处的字符加下划线。 更多的CTERM颜色可以查阅： http://vim.wikia.com/wiki/Xterm256_color_names_for_console_Vim 禁用/启用高亮 有木有觉得每次查找替换后 Vim 仍然高亮着搜索结果？ 可以手动让它停止高亮，在normal模式下输入： : nohighlight \" 等效于 : nohl 其实上述命令禁用了所有高亮，只禁用搜索高亮的命令是 :set nohlsearch 。 下次搜索时需要 :set hlsearch 再次启动搜索高亮。 延时禁用 怎么能够让Vim查找/替换后一段时间自动取消高亮，发生查找时自动开启呢？ \" 当光标一段时间保持不动了，就禁用高亮 autocmd cursorhold * set nohlsearch \" 当输入查找命令时，再启用高亮 noremap n : set hlsearch < cr > n noremap N : set hlsearch < cr > N noremap / :set hlsearch<cr>/ noremap ? : set hlsearch < cr > ? noremap * *: set hlsearch < cr > 将上述配置粘贴到 ~/.vimrc ，重新打开vim即可生效。 一键禁用 如果延时禁用搜索高亮仍然不够舒服，可以设置快捷键来一键禁用/开启搜索高亮： noremap n : set hlsearch < cr > n noremap N : set hlsearch < cr > N noremap / :set hlsearch<cr>/ noremap ? : set hlsearch < cr > ? noremap * *: set hlsearch < cr > nnoremap < c - h > : call DisableHighlight ()< cr > function ! DisableHighlight () set nohlsearch endfunc 希望关闭高亮时只需要按下 Ctrl+H ，当发生下次搜索时又会自动启用。 参考阅读 XTERM 256色： http://vim.wikia.com/wiki/Xterm256_color_names_for_console_Vim Vim Wikia - 查找与替换： http://vim.wikia.com/wiki/Search_and_replace 用 Vim 打造 IDE 环境： https://harttle.land/2015/11/04/vim-ide.html -= 完 =-","tags":"VIM","url":"https://doobom.me/search-and-replace-in-vim","loc":"https://doobom.me/search-and-replace-in-vim"},{"title":"How To Used Git","text":"1.使用git bash创建一个文件夹 cd g: cd GitLearning mkdir LearningPythonDiary 2.初始化代码仓库 git init 3.添加一个文件到仓库的缓存区（从工作目录添加到缓存区） git add filename 4.将添加的文件从缓存区提交到HEAD（最近一次提交后的结果） git commit -m \"代码提交信息\" 5.将本地代码仓库中代码push到gitHub上 首先需要用我们在gitHub上的邮箱与用户名生成一个.ssh（id_rsa.pub） git config -- global user . name \"Your Name Here\" # Sets the default name for git to use when you commit git config -- global user . email \"your_email@example.com\" # Sets the default email for git to use when you commit 然后将生成的id_rsa.pub 中最后== 添加上自己在gitHub上的邮箱地址，全选一起拷贝到在gitHub上同样项目的 domay key中。 然后在git中创建主干线(ssh方式) git remote add origin git@github.com:username/LearningPythonDiary.git 也可以这样创建（https方式）： git remote add origin https://github.com/username/LearningPythonDiary.git 不过这样创建就是每次提交的时候都要输入用户名与密码，比较繁琐。 push到github中的同名项目中 git push origin master 6.将gitHub上的代码更新到本地 git pull origin master 7.从gitHub上复制项目到本地localhost git clone https://github.com/username/LearningPythonDiary.git master 转自https://github.com/peterluo/LearningPythonDiary","tags":"git","url":"https://doobom.me/how-to-used-git","loc":"https://doobom.me/how-to-used-git"},{"title":"Hello World","text":"Hello World, Hello Pelican. and ~oops.run~ doobom.me","tags":"Pelican","url":"https://doobom.me/hello-world","loc":"https://doobom.me/hello-world"}]};